<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UMD Drop and Catch Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #7A0019 0%, #FFCC33 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 400px;
            height: 600px;
            background: linear-gradient(to bottom, #FFCC33 0%, #7A0019 100%);
            border: 3px solid #7A0019;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(122,0,25,0.4);
        }

        .game-header {
            background: rgba(122,0,25,0.9);
            color: #FFCC33;
            padding: 10px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }

        .score-board {
            display: flex;
            justify-content: space-between;
            padding: 5px 20px;
            background: rgba(255,204,51,0.9);
            color: #7A0019;
            font-weight: bold;
        }

        .game-area {
            position: relative;
            width: 100%;
            height: calc(100% - 80px);
            background: linear-gradient(to bottom, #FFF8DC 0%, #F5F5DC 100%);
        }

        .catcher {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 20px;
            background: linear-gradient(45deg, #7A0019, #FFCC33);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(122,0,25,0.4);
            transition: left 0.1s ease;
        }

        .falling-object {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            /* Drop shadow removed for cleaner look */
            animation: fall linear;
        }

        .good-object {
            /* UMD Bulldog image for good objects */
            background: url('images/umd-bulldog.png') center center / contain no-repeat;
            width: 50px;            /* match increased object size */
            height: 50px;
            border-radius: 0;       /* keep logo shape */
            background-color: transparent;
        }

        .bad-object {
            /* UMD Maryland flag ball for bad objects */
            background: url('images/umd-maryland.png') center center / cover no-repeat;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: transparent;
        }

        .bonus-object {
            /* Gold Bulldog image for bonus objects */
            background: url('images/umd-bulldog-gold.png') center center / contain no-repeat;
            width: 50px;            /* match increased object size */
            height: 50px;
            border-radius: 0;       /* keep logo shape */
            background-color: transparent;
            /* No extra animation here so it inherits the fall animation */
        }

        @keyframes fall {
            from {
                top: -30px;
            }
            to {
                top: 100%;
            }
        }

        @keyframes sparkle {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        .game-over h2 {
            margin-bottom: 20px;
            color: #FFCC33;
        }

        .restart-btn {
            background: linear-gradient(45deg, #7A0019, #FFCC33);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.2s;
        }

        .restart-btn:hover {
            transform: scale(1.05);
        }

        .instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(122,0,25,0.8);
            color: #FFCC33;
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 200px;
        }

        .level-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,204,51,0.9);
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            color: #7A0019;
        }

        .music-control {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(122,0,25,0.9);
            color: #FFCC33;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .music-control:hover {
            background: rgba(255,204,51,0.9);
            color: #7A0019;
            transform: scale(1.05);
        }

        .music-control.playing {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            UMD Drop and Catch Game
        </div>
        
        <div class="score-board">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
        </div>

        

        <div class="game-area" id="gameArea">
            <div class="catcher" id="catcher"></div>
        </div>

        <div class="game-over" id="gameOver">
            <h2>Game Over!</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Level Reached: <span id="finalLevel">1</span></p>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <div class="level-indicator">
        Level: <span id="level">1</span>
    </div>

    <div class="instructions">
        üéÆ Use A/D or ‚Üê/‚Üí to move<br>
        üü¢ Catch green objects (+10)<br>
        üî¥ Avoid red objects (-1 life)<br>
        üü° Catch gold for bonus (+50)
    </div>

    <button class="music-control" id="musicControl" onclick="toggleMusic()">
        üéµ Music: Off
    </button>

    <script>
        class MusicGenerator {
            constructor() {
                this.audioContext = null;
                this.isPlaying = false;
                this.oscillators = [];
                this.gainNodes = [];
                this.intervals = [];
                this.isInitialized = false;
            }

            init() {
                if (this.isInitialized) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.isInitialized = true;
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }

            start() {
                if (!this.isInitialized) this.init();
                if (!this.audioContext || this.isPlaying) return;

                this.isPlaying = true;
                
                // Create multiple oscillators for a richer sound
                const frequencies = [261.63, 329.63, 392.00, 523.25]; // C, E, G, C
                
                frequencies.forEach((freq, index) => {
                    setTimeout(() => {
                        if (!this.isPlaying) return;
                        
                        const oscillator = this.audioContext.createOscillator();
                        const gainNode = this.audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime);
                        oscillator.type = index % 2 === 0 ? 'sine' : 'triangle';
                        
                        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.05, this.audioContext.currentTime + 0.5);
                        gainNode.gain.linearRampToValueAtTime(0.02, this.audioContext.currentTime + 1.5);
                        
                        oscillator.start();
                        
                        this.oscillators.push(oscillator);
                        this.gainNodes.push(gainNode);
                        
                        // Schedule frequency changes
                        this.scheduleFrequencyChange(oscillator, freq, index);
                        
                    }, index * 200);
                });

                // Add bass line
                setTimeout(() => {
                    if (!this.isPlaying) return;
                    
                    const bassOsc = this.audioContext.createOscillator();
                    const bassGain = this.audioContext.createGain();
                    
                    bassOsc.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);
                    
                    bassOsc.frequency.setValueAtTime(130.81, this.audioContext.currentTime); // C3
                    bassOsc.type = 'sawtooth';
                    
                    bassGain.gain.setValueAtTime(0.03, this.audioContext.currentTime);
                    
                    bassOsc.start();
                    
                    this.oscillators.push(bassOsc);
                    this.gainNodes.push(bassGain);
                }, 1000);
            }

            scheduleFrequencyChange(oscillator, baseFreq, index) {
                if (!this.isPlaying) return;
                
                const interval = setInterval(() => {
                    if (!this.isPlaying) {
                        clearInterval(interval);
                        return;
                    }
                    
                    // Change to related frequencies
                    const notePattern = [0, 4, 7, 12, 7, 4, 0, -5]; // Major scale pattern
                    const patternIndex = Math.floor(Math.random() * notePattern.length);
                    const semitoneOffset = notePattern[patternIndex];
                    const newFreq = baseFreq * Math.pow(2, semitoneOffset / 12);
                    
                    oscillator.frequency.setValueAtTime(newFreq, this.audioContext.currentTime);
                }, 1000 + Math.random() * 2000);
                
                this.intervals.push(interval);
            }

            stop() {
                this.isPlaying = false;
                
                // Stop all oscillators
                this.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                    } catch (e) {
                        // Oscillator might already be stopped
                    }
                });
                
                // Clear all intervals
                this.intervals.forEach(interval => clearInterval(interval));
                
                this.oscillators = [];
                this.gainNodes = [];
                this.intervals = [];
            }

            toggle() {
                if (this.isPlaying) {
                    this.stop();
                } else {
                    this.start();
                }
            }
        }

        class DropCatchGame {
            constructor() {
                this.gameArea = document.getElementById('gameArea');
                this.catcher = document.getElementById('catcher');
                this.scoreElement = document.getElementById('score');
                this.livesElement = document.getElementById('lives');
                this.levelElement = document.getElementById('level');
                this.gameOverElement = document.getElementById('gameOver');
                this.finalScoreElement = document.getElementById('finalScore');
                this.finalLevelElement = document.getElementById('finalLevel');
                this.musicControl = document.getElementById('musicControl');

                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameRunning = false;
                this.catcherPosition = 50; // percentage
                this.fallingObjects = [];
                this.gameSpeed = 2000; // milliseconds between drops
                this.dropInterval = null;

                // Initialize music generator
                this.musicGenerator = new MusicGenerator();

                this.init();
            }

            init() {
                this.setupEventListeners();
                this.startGame();
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (!this.gameRunning) return;

                    switch(e.key.toLowerCase()) {
                        case 'a':
                        case 'arrowleft':
                            this.moveCatcher(-10);
                            break;
                        case 'd':
                        case 'arrowright':
                            this.moveCatcher(10);
                            break;
                    }
                });

                // Touch/mouse support for mobile
                this.gameArea.addEventListener('click', (e) => {
                    if (!this.gameRunning) return;
                    
                    const rect = this.gameArea.getBoundingClientRect();
                    const clickX = e.clientX - rect.left;
                    const clickPercentage = (clickX / rect.width) * 100;
                    
                    if (clickPercentage < this.catcherPosition) {
                        this.moveCatcher(-20);
                    } else {
                        this.moveCatcher(20);
                    }
                });
            }

            moveCatcher(delta) {
                this.catcherPosition = Math.max(0, Math.min(100, this.catcherPosition + delta));
                this.catcher.style.left = this.catcherPosition + '%';
            }

            startGame() {
                this.gameRunning = true;
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameSpeed = 2000;
                this.fallingObjects = [];
                
                this.updateDisplay();
                this.gameOverElement.style.display = 'none';
                
                this.dropInterval = setInterval(() => {
                    this.createFallingObject();
                }, this.gameSpeed);

                this.gameLoop();
            }

            createFallingObject() {
                if (!this.gameRunning) return;

                const object = document.createElement('div');
                object.className = 'falling-object';
                
                // Random position
                const leftPosition = Math.random() * 85 + 7.5; // 7.5% to 92.5%
                object.style.left = leftPosition + '%';
                
                // Random object type
                const objectType = Math.random();
                let points = 0;
                let isBad = false;
                
                if (objectType < 0.6) {
                    // 60% chance for good object
                    object.classList.add('good-object');
                    points = 10;
                } else if (objectType < 0.9) {
                    // 30% chance for bad object
                    object.classList.add('bad-object');
                    isBad = true;
                } else {
                    // 10% chance for bonus object
                    object.classList.add('bonus-object');
                    points = 50;
                }

                // Random fall speed
                const fallSpeed = Math.random() * 2 + 1; // 1-3 seconds
                object.style.animationDuration = fallSpeed + 's';

                this.gameArea.appendChild(object);
                
                this.fallingObjects.push({
                    element: object,
                    left: leftPosition,
                    points: points,
                    isBad: isBad,
                    caught: false
                });

                // Remove object after animation
                setTimeout(() => {
                    if (object.parentNode) {
                        this.removeObject(object, false);
                    }
                }, fallSpeed * 1000);
            }

            removeObject(objectElement, wasCaught) {
                const objectIndex = this.fallingObjects.findIndex(obj => obj.element === objectElement);
                if (objectIndex !== -1) {
                    const object = this.fallingObjects[objectIndex];
                    
                    if (wasCaught) {
                        if (object.isBad) {
                            // Bad object caught - lose a life
                            this.lives--;
                            this.updateDisplay();
                            
                            if (this.lives <= 0) {
                                this.gameOver();
                            }
                        } else {
                            // Good or bonus object caught - add points
                            this.score += object.points;
                            this.updateDisplay();
                            
                            // Check for level up
                            if (this.score > 0 && this.score % 100 === 0) {
                                this.levelUp();
                            }
                        }
                    } else if (object.isBad) {
                        // Bad object missed - no penalty
                    } else {
                        // Good object missed - lose life
                        this.lives--;
                        this.updateDisplay();
                        
                        if (this.lives <= 0) {
                            this.gameOver();
                        }
                    }
                    
                    this.fallingObjects.splice(objectIndex, 1);
                }
                
                if (objectElement.parentNode) {
                    objectElement.remove();
                }
            }

            levelUp() {
                this.level++;
                this.gameSpeed = Math.max(500, this.gameSpeed - 200); // Faster drops
                
                // Clear current interval and set new one
                clearInterval(this.dropInterval);
                this.dropInterval = setInterval(() => {
                    this.createFallingObject();
                }, this.gameSpeed);
                
                this.updateDisplay();
                
                // Visual feedback for level up
                this.showLevelUpEffect();
            }

            showLevelUpEffect() {
                const effect = document.createElement('div');
                effect.style.position = 'absolute';
                effect.style.top = '50%';
                effect.style.left = '50%';
                effect.style.transform = 'translate(-50%, -50%)';
                effect.style.color = '#FFD700';
                effect.style.fontSize = '24px';
                effect.style.fontWeight = 'bold';
                effect.style.pointerEvents = 'none';
                effect.style.zIndex = '1000';
                effect.textContent = `Level ${this.level}!`;
                
                this.gameArea.appendChild(effect);
                
                setTimeout(() => {
                    effect.remove();
                }, 2000);
            }

            gameOver() {
                this.gameRunning = false;
                clearInterval(this.dropInterval);
                
                // Clear all falling objects
                this.fallingObjects.forEach(obj => {
                    if (obj.element.parentNode) {
                        obj.element.remove();
                    }
                });
                this.fallingObjects = [];
                
                this.finalScoreElement.textContent = this.score;
                this.finalLevelElement.textContent = this.level;
                this.gameOverElement.style.display = 'block';
            }

            updateDisplay() {
                this.scoreElement.textContent = this.score;
                this.livesElement.textContent = this.lives;
                this.levelElement.textContent = this.level;
            }

            gameLoop() {
                if (!this.gameRunning) return;

                // Check collisions
                this.fallingObjects.forEach(obj => {
                    if (obj.caught) return;

                    const objectRect = obj.element.getBoundingClientRect();
                    const catcherRect = this.catcher.getBoundingClientRect();
                    
                    // Check if object is near the catcher
                    if (objectRect.bottom >= catcherRect.top && 
                        objectRect.top <= catcherRect.bottom &&
                        objectRect.left < catcherRect.right && 
                        objectRect.right > catcherRect.left) {
                        
                        obj.caught = true;
                        this.removeObject(obj.element, true);
                    }
                });

                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // Global functions
        function restartGame() {
            game.startGame();
        }

        function toggleMusic() {
            game.musicGenerator.toggle();
            const button = document.getElementById('musicControl');
            
            if (game.musicGenerator.isPlaying) {
                button.textContent = 'üéµ Music: On';
                button.classList.add('playing');
            } else {
                button.textContent = 'üéµ Music: Off';
                button.classList.remove('playing');
            }
        }

        // Initialize game when page loads
        let game;
        window.addEventListener('load', () => {
            game = new DropCatchGame();
        });
    </script>
</body>
</html>
